% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mmrm.R
\name{mmrm}
\alias{mmrm}
\title{Fits MMRM model using nlme::gls}
\usage{
mmrm(
  formula,
  time,
  subjects,
  data,
  heterogenous = TRUE,
  cov_struct = c("unstructured", "toeplitz", "autoregressive", "compound-symmetry",
    "identity"),
  method = "REML",
  na.action = na.exclude,
  control = list(),
  verbose = FALSE,
  return_all = FALSE,
  stop_on_convergence = TRUE,
  ...
)
}
\arguments{
\item{formula}{formula for the fixed effects structure of the model}

\item{time}{the time variable of the model}

\item{subjects}{the variable indicating unique subjects}

\item{data}{the data structure}

\item{heterogenous}{boolean flag for heterogenous vs. homogenous variance.
If heterogenous = TRUE, uses different variance parameters
at each time point. If heterogenous = FALSE,
one variance paramter across all time points.}

\item{cov_struct}{a sequence of covariance matrix specifications;
will fit a model starting with the first covariance
and check for convergence. If there are convergence
issues, it will iterate through the rest of the list
until the model converges.}

\item{method}{character, either "REML" or "ML". If "REML" the model is fit
by maximizing the restricted log-likelihood. If "ML" the
log-likelihood is maximized. Defaults to "REML".}

\item{na.action}{a function that indicates what should happen when the
data contain NAs. Defaults to na.omit}

\item{control}{a list of control values fo the estimation algorithm to
to replace the default values returned by the function
\link[nlme:glsControl]{nlme::glsControl}}

\item{verbose}{logical value indicating whether to print the
evolution of the iterative algorithm. Default is FALSE}

\item{return_all}{logical; if TRUE, will return all models that were fit,
if FALSE, only returns the first model that converged
or last model attempted (if all failed).}

\item{stop_on_convergence}{ignored if return_all = FALSE.
if return_all = TRUE, stop fitting models and
return results once one model converges if
stop_on_convergence = TRUE. if return_all = TRUE
and stop_on_convergence = FALSE, fits and
returns all specified models}
}
\value{
\code{mmrmObject} or \code{mmrmList}, a list of \code{mmrmObjects}

If return_all = FALSE, returns only the mmrmObject of the first model to
converge or the last attempted model.\cr
If return_all = TRUE, returns list of all attempted models.
}
\description{
Fits a Mixed Model Repeated Measures model (see Details).
In this implementation, the fixed effects structure is flexible --
it is user defined using a formula. This implementation does not support
the inculsion of random effects, and it specifies that the residual variance
at each time point is independent and residuals of individual subjects
are correlated across timepoints.
}
\details{
The MMRM implemented here is defined as:
\deqn{Y_i = X_i\beta + \epsilon_i}
\deqn{\epsilon_i \sim \mathcal{N}(0, \Sigma_i)}
\itemize{
\item \eqn{Y_i} as the vector of outcomes with length
\eqn{n_{subjects}*n_{timepoints}}
\item \eqn{X_i} as the a matrix of predictors with
\eqn{n_{subjects}*n_{timepoints}} rows and \eqn{n_{predictors}} columns
\item \eqn{\beta} as the vector of coefficients with length \eqn{n_{predictors}}
\item \eqn{\epsilon_i} as the vector of residuals
\item \eqn{\Sigma_i} as the (\eqn{n_{subjects}*n_{timepoints} x n_{subjects}*(n_{timepoints}}) covariance matrix
}

This implementation of the MMRM supports three different
covariance structures: unstructured, toeplitz, AR(1), and compound symmetry.
Timepoints are always treated as categorical,
with independent residual variance at each timepoint and correlated residuals
among individual subjects across timepoints.
}
\examples{
\dontrun{
mmrm(
  outcome ~ baseline + group + time +
    baseline:time + group:time,
  time = "time",
  subjects = "subjectid",
  data = my_data
)
}

}
